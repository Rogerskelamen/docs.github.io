# python装饰器

​		**简言之，python装饰器就是用于==拓展原来函数功能的一种函数==，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。**

我们来看看**讲odoo入门的书**是怎么说的

> 出现的背景：假如，我们有一个base项目组谢了一两个函数f1()和f2()，然受又有其他的两个项目组e1和e2要调用这两个函数。如此这两个函数被e1和e2项目组使用了一段时间以后，base项目组决定对这两个函数层架权限检查的功能，有权限才可调用，无权限则会失败。
> 有没有**既不需要调用方修改代码，又能够不调整方法的代码**就能实现增加权限功能的方式呢？于是，装饰器诞生了！

其实，两种说法都是要使得**不用更改原函数的代码前提下给函数增加新的功能**。*（总感觉类似于继承的关系）*

###### 我们看看这样的一个代码：

```py
#既不需要侵入，也不需要函数重复执行
import time

def deco(func):
    def wrapper():
        startTime = time.time()
        func()
        endTime = time.time()
        msecs = (endTime - startTime)*1000
        print("time is %d ms" %msecs)
    return wrapper

@deco
def func():
    print("hello")
    time.sleep(1)
    print("world")

if __name__ == '__main__':
    f = func #这里f被赋值为func，执行f()就是执行func()
    f()
```

这里的deco函数就是最原始的装饰器，其参数是一个函数`func()`，其返回值也是一个函数。于是，函数func()就在函数`wrapper()`内部执行。
加上`@deco`的func()就被注入了新的函数功能，**扩展为了“更多新功能”的函数**。

**<u>所以装饰器就像是一个注入符号：有了它，拓展了原来的函数的功能就不必更改函数内部代码，也不必重复执行新写的函数。</u>**

***注意： 函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。***



> ### 拓展

1. `@`相当于将外面的装饰器函数与内部调用的函数联系在一起，相当于

   ```python
   s = deco(func)
   s()
   ```

2. 当有多个参数或参数不定时，使用`*args`和`**kwargs`。

3. 多个装饰器执行的顺序就是从最后一个装饰器开始，执行到第一个装饰器，再执行函数本身。



## python语法拓展

* ### self

  方法与函数的区别是类的方法需要通过self关键字带哦用，该关键字是Python提供的指向对象本省的变量。*（通过按住ctrl也可以看出）*

* ### args，kwargs

  **args，kwargs是什么？**

  * `args`和`kwargs`都是形参符号，相当于js里面的arguement，放在函数的形参表里面。
  * `args`用来接收元组类型的参数，而`kwargs`用来接收字典类型的参数。
  * 一般都是args在前，kwargs在后，那样首先接收的就是元组（数字值），直到碰到键值对类型的参数才会开始接收字典参数。
  * 其写法是加上\*\* ，如`*args`，`**kwargs`。
  * 其实python带有类dict，可以使用`dict(e = 3)、dict(a = 1, b = 2, c = 3)`创建一个字典。

* ### \_\_name\__ == '\_\_main__'

  `if __name__ == '__main__'`这是在干啥？

  \_\_name__ 是当前模块名，当模块被直接运行时模块名为 \_\_main__ 。这句话的意思就是，当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。